This project builds upon the Model implementation of a shapes album application, and completes the View and Controller
implementations. The model was only slightly changed from the previous submission: the Snapshot IDs was changed from an
integer that was generated by the Snapshot's hashcode divided by an offset to a simple String that incremented by 1
for each new Snapshot. This was done to make the Snapshot IDs more readable and also because the way the equals method
was written sometimes resulted in the same ID being generated for two different Snapshots. Other than this, the model
remained unchanged.

The main feature of the model design was the use of the command design pattern. I stated in the
last submission that my hope was that the model design would allow me to easily add new commands to the application from
the controller. After completing the controller, I was pleased to see that the model design was successful. In my
controller, I parse the commands .txt file from the user and, once validated/cleaned, I simply loop through the commands
and invoke the same commandReceiver() method to dispatch all commands dealing with shapes and snapshots. I think this
makes for a clean and easy to understand relationship between the controller and the model.

Once the commands were executed, I then call upon the relevant view methods to display the results. There are two views,
the designs of which are detailed below:
1. Graphical View: uses Swing to display the shapes and snapshots in a graphical window. As I was new to Swing, this was
the part of the project that took the longest to complete. After reading some of the documentation and watching a few
tutorials, I decided to that my graphical view will make use of three JPanels: a top panel that displays information
about the snapshot, a middle panel the displays the snapshot itself, and then a bottom panel that will host the buttons.

To toggle between the snapshots, I chose to re-render the panels every time a new snapshot is selected. I did this by
using and constantly updating a variable (currentSnapshotIndex) that keeps track of the index of the current snapshot.
I use this index to access the current snapshot from the snapshotList, and then I use the snapshot's getShapes() method
to get the list of shapes that are associated with the snapshot. I then loop through the list of shapes and render them
to the middle panel using the ShapePanel class.

In retrospect, I think this is not the most efficient solution. If I were to start over, I would have pre-rendered the
snapshots and stored them in some sort of array structure. Then, when a new snapshot is selected, I would simply display
 the associated panels from the array. This would have been more efficient because it would have eliminated the need to
re-render the panels every time a new snapshot is selected. And I believe this approach would also be space/time
efficient, and could allow me to save snapshots to a file and then load them back in later, if I wanted to create
that feature.

2. Text View: this view creates a simple static html and svg file that displays the snapshots and associated info. There
are three methods: one that creates the svg code for each shape in the snapshot, another that uses a string builder to
create the html code for the snapshot, and a third that creates the html file and writes the html code into it generated
by the previous two methods. If I wanted to challenge myself more, I could have considered creating "frames" for each
snapshot, or added more dynamic features to the html file.

For the views, I decided to create two separate view interfaces, as they have very different methods, and I could not
think of a way to distill any common features into a single (or parent) interface.

Ultimately, I am happy with the results of the project, especially the results of the model design and how easy it
made the controller implementation. I think my biggest improvements can be made in the view design and also unit testing
for the controller.